# Case

## 难点 8 虚拟列表

长列表渲染问题：渲染长列表容易造成页面阻塞，影响用户体验。

解决方案：

1. 时间分片：将长列表分片，一次只渲染一部分数据，减少渲染压力
   - 效率低
   - 不直观
   - 性能差
2. 虚拟列表（_推荐_）：设置**可视区域**，滚动列表时，**动态修改**可视区域的内容

实现方案：

假设每一项定高，需要得到：

1. 起始项索引 start index
2. 结束项索引 end index
3. 可视区域的项
4. 整个列表中的偏移量 offset

```html
<div class="container">
  <!-- 占位，高度相当于列表总高度，用于撑开滚动条 -->
  <div class="phantom"></div>
  <!-- 可视区域，与占位重叠 -->
  <div class="list">
    <!-- 列表项渲染区域 -->
  </div>
</div>
```

监听 container 的滚动事件，获取滚动的 `scrollTop`

- 假设可视区域高度固定 `screenHeight`
- 列表项固定高度 `itemHeight`

可以计算得出：

- 列表总高度：总数量 \* 项高度
- 可视数量：`screenHeight / itemHeight` _向上取整_
- 起始索引：`scrollTop / itemHeight` _向下取整_
- 结束索引：起始索引 + 可视数量

> 由于 list 和 phantom 都定位在 container 内部，所以它们会同步滚动。
> 发生滚动后，由于渲染区和可视区发生了偏移，需要计算偏移量，然后使用 `translateY` 将 list 重新移回可视区。

渲染区域和可视区域的偏移量：`scrollTop - (scrollTop % itemHeight)`

### 动态高度

实际应用中，列表项的高度可能不一致：

1. 如何获取真实高度？
2. 相关高度计算有何变化？
3. 渲染方式有什么改变？（不变）

解决方案：

1. 采用预估高度先渲染，再根据 DOM 实际高度去设置真是高度
2. 先创建一个缓存列表，记录每一项的索引、高度、定位
3. 起始索引：缓存列表中第一个定位值大于 `scrollTop` 的索引

完整步骤：

1. 父组件传入预估高度
2. 缓存列表：根据预估高度初始化

   ```js
   const cache = [
     {
       index: 0,
       itemHeight: 0, // 预估高度
       top: index * itemHeight
       bottom: (index + 1) * itemHeight
     }
   ]
   ```

3. 每次渲染到可视区域时，获取 DOM 的真实高度，并更新缓存列表，并更新偏移量
   - vue 使用 `updated()` 钩子
4. 重写 onScroll 事件，计算起始索引
   - 遍历缓存列表，找到第一个定位值大于 `scrollTop` 的索引

优化点：cache 是一个有序数组，可以作查找优化，使用二分查找。

- `find` 顺序查找：`O(n)`
- 二分查找：`O(log n)`

### 白屏问题

仅渲染可视区域的元素，如果用户滚动太快，可能出现白屏。

- 在可视区域前后增加缓冲区（一定比例）
- 根据比例计算上下缓存区的数量
- 渲染时加上上下缓冲区
- 偏移量计算也需要考虑缓冲区

其他优化点：

- `onScroll` 会频繁计算
- 列表含有图片，无法保证高度计算的准确性

## 难点 15 多文件类型预览

不同类型的文件文件运行时是不一样的

- 浏览器自身支持的文件
- 第三方库支持

浏览器支持的文件（图片、视频、音频）：`fileReader` --> `dataUrl`
纯文本：直接读取
office 类型文件：

- `vue-office`
- 微软官方
- `kkfileview`

pdf 文件：`iframe` 直接引入

## SKU 临界矩阵算法

多个规格参数组合判断可购买状态。

- 根据库存，禁用状态等因素，通过规格 ID 构建可选路径
- 再根据选中项进行动态判断路径的可行性
- 根据选择项和可行性展示具体状态

## 大文件上传

问题：

1. 文件过大，上传过程可能失败
2. hash 过久，计算时间长

方案：

1. 文件分片：将大的事务，分为多个小的事务
2. 先分片，在对每个分片hash, 最后整体hash
3. 默认文件未上传过，先上传再异步计算hash，计算完成后补充到接口中

步骤：

1. 用文件信息（名称，大小，分片大小）换取 uploadId
2. 单片 hash 校验
3. 整个文件 hash 换取 缺少的分片
4. 发起合并请求
